# 面向对象（Object Oriented Programming） #

----------

# 1.面向对象和面向过程的区别 #

	**面向过程**
	
	优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
	
	缺点：没有面向对象易维护、易复用、易扩展
	
	**面向对象**
	
	优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
	
	缺点：性能比面向过程低

# 2.面向对象的三个基本特征是： #

	抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。（java特征）	
	
	封装：就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

	继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

	多态：多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
	
	实现多态，有二种方式，覆盖，重载。
	
	覆盖，是指子类重新定义父类的虚函数的做法。
	重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

# 3.面向对象的六大设计原则： #


    1、单一职责原则：避免职责分散，避免承担太多（SRP）

    2、开闭原则：模块应对扩展开放，而对修改关闭（OCP）。

    3、里氏代换原则：子类必须能替换掉父类（LSP）。

    4、依赖倒转原则：父类不依赖子类，抽象不依赖具体（DIP）

    5、接口隔离原则：职业单一，承诺最简（ISP）

    6、组合复用原则：尽量使用组合，避免滥用继承（CRP）



# java #

----------


# 1.JAVA中的栈内存与堆内存 #
	
	1.栈内存：存放局部变量，超出作用域会被回收；Stack空间小，速度比较快，用来放对象的引用，数据大小和生存期是必须确定的，缺乏灵活性，栈可以共享
		
	2.堆内存：创建出来的对象，有java垃圾回收器回收，可以动态分配内存的大小，生存期不必告诉编译器，但存取速度较慢。

# 2.static与类共存亡； 非static与对象共存亡！！ #

# 3.对象： #

	1.== ：比较的是栈内存中的值（地址）
	
	2.equals ： 比较的是内容，重写该方法才有意义！！重写equals方法需要重写hashcode()方法
	
	3.创建对象的四种方式：new,classLoader,clone,反序列化

	4.equals相等，hashcode必相等；hashcode相等，equals可能不相等

# 4.函数传参是：基本类型是值的拷贝的传递；引用类型是引用的传递！！ #

# 5.String的理解： #

### String类是final类故不可以继承，一切由final修饰过的都不能继承。
### String是不可变的，线程安全；
### StringBuffer是可变的，对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全
###StringBuilder是可变的，没有对方法进行加同步锁，所以是非线程安全的。

new出来的对象与直接写的的区别！！！

	 String s1 = new String("abc");　　　　//2个对象
	 String s2 = new String("abc");　　　　//2个对象 
	 System.out.println("s1 == s2 : " + (s1 == s2));//false
	 System.out.println("s1.equals(s2) : " + s1.equals(s2));//true
	  
	
	 String s3 = "abc";
	 String s4 = "abc";	 
	 System.out.println("s3 == s4 : " + (s3 == s4));//true
	 System.out.println("s3.equals(s4) : " + s3.equals(s4));//true



#  6.getClass： #

	　　　　Class字节码的获取：
	
	　　　　　　1.通过对象获取；　　　　对象.getClass()
	
	　　　　　　2.通过类获取；　　　　　类.Class
	
	　　　　　　3.Class的forName方法获取。　　Class.forName("com.westos.javase.lesson04_2.Person");　　------->　　注意全名

# 7.抽象类： #
	
	　　　　抽象类天生就是用来被继承的；
	
	　　　　抽象类不能被实例化，但可以定义变量指向子类对象；
	
	　　　　其子类必须重写所有方法，否则也必须声明为抽象类； 
	
	　　　　抽象类中可以没有抽象方法；
	
	　　　　抽象类和普通类一样，有构造方法！！！

 

# 8.接口 #

	　　　　接口中所有方法都是抽象的  ----->　　public abstract 
	
	　　　　接口中的变量都是　　-------> 　　public static final
	
	　　　　一个类只能继承一个类，但可以实现多个接口：public class SuperMan extends Person implements Run_able,Flyable { }
	
	　　　　　　解决了不能多继承的问题！！

 

# 9.抽象类与接口的区别： #

	　　　　抽象类是继承，接口是实现；
	
	　　　　抽象类是 is a；接口是 like a；
	
	　　　　抽象类定义的是体系内的功能； 接口定义的是体系外的扩展功能！！

# 10.重载和重写的区别 #
	重载(overload)：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

	特点  
	1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；  
	2、不能通过访问权限、返回类型、抛出的异常进行重载；  
	3、方法的异常类型和数目不会对重载造成影响；  
	4、重载事件通常发生在同一个类中，不同方法之间的现象。
	5、存在于同一类中，但是只有虚方法和抽象方法才能被覆写。

	重写（override）：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写

	特点  
	1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；  
	2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；  
	3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；
	4、方法被定义为final不能被重写。 
	5、对于继承来说，如果某一方法在父类中是访问权限是private，那么就不能在子类对其进行重写覆盖，如果定义的话，也只是定义了一个新方法，而不会达到重写覆盖的效果。（通常存在于父类和子类之间。）

	①方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系。 
	②覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。 
	③覆盖要求参数列表相同；重载要求参数列表不同。 
	④覆盖关系中，调用那个方法体，是根据对象的类型（对象对应存储空间类型）来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。

# 11.访问控制符public,protected,private,以及默认的区别 #
	private只有在本类中才能访问；
	public在任何地方都能访问；
	protected在同包内的类及包外的子类能访问；
	默认不写在同包内能访问。

# 12.Java中主要有8中基本数据类型 #
	byte,short,int,long,char,boolean,float,double

# 13.java线程安全理解 #
	如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。
	如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。


# 14.自动装箱与拆箱 #
	装箱：将基本类型用它们对应的引用类型包装起来；
	拆箱：将包装类型转换为基本数据类型；
	Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。

# 15.HashMap和HashTable区别 #

	1）.HashTable的方法前面都有synchronized来同步，是线程安全的；HashMap未经同步，是非线程安全的。
	2）.HashTable不允许null值(key和value都不可以) ；HashMap允许null值(key和value都可以)。
	3）.HashTable使用Enumeration进行遍历；HashMap使用Iterator进行遍历。
	4）.HashTable中hash数组默认大小是11，增加的方式是old*2+1；HashMap中hash数组的默认大小是16，而且一定是2的指数。
	5）.哈希值的使用不同，HashTable直接使用对象的hashCode； HashMap重新计算hash值，而且用与代替求模。
	6）.HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”
	7).这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。
	8).“当两个对象的hashcode相同会发生什么？” 他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用LinkedList存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在LinkedList中。
	9).“如果两个键的hashcode相同，你如何获取值对象？” 当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。如果有两个值对象储存在同一个bucket，将会遍历LinkedList直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？HashMap在LinkedList中存储的是键值对找到bucket位置之后，会调用keys.equals()方法去找到LinkedList中正确的节点，最终找到要找的值对象
	10).默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。

# 16.ArrayList和vector,linkedList的存储性能和特性 #
	ArrayList和Vector都实现了List接口，都是通过数组实现的。此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢.
	Vector由于使用了synchronized方法（线程安全），而ArrayList是非线程安全的，通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
	List第一次创建的时候，会有一个初始大小，随着不断向List中增加元素，当List 认为容量不够的时候就会进行扩容。Vector缺省情况下自动增长原来一倍的数组长度，ArrayList增长原来的50%。


# 17.ArrayList和LinkedList区别及使用场景 #
	区别
	ArrayList底层是用数组实现的，可以认为ArrayList是一个可改变大小的数组。随着越来越多的元素被添加到ArrayList中，其规模是动态增加的。
	LinkedList底层是通过双向链表实现的， LinkedList和ArrayList相比，增删的速度较快。但是查询和修改值的速度较慢。
	使用场景
	LinkedList更适合从中间插入或者删除（链表的特性）。
	ArrayList更适合检索和在末尾插入或删除（数组的特性）。

# 18.线程的实现方式 #
	继承Thread类、实现Runnable接口、使用线程池ExecutorService、Callable、Future实现有返回结果的多线程。

# 19.synchronized和Lock的区别 #

	主要相同点：Lock能完成synchronized所实现的所有功能
	主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。Lock的锁定是通过代码实现的，而synchronized是在JVM层面上实现的，synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。Lock锁的范围有局限性，块范围，而synchronized可以锁住块、对象、类。

# 20.sleep和wait的区别(考察的方向是是否会释放锁) #
	sleep()方法是Thread类中方法，而wait()方法是Object类中的方法。
	sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。

# 21.Java中的NIO，BIO，AIO分别是什么 #
	BIO:同步并阻塞
	NIO:同步非阻塞
	AIO:异步非阻塞

# 22.Java类加载器及如何加载类(双亲委派) #

	启动（Bootstrap）类加载器：由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。

	扩展（Extension）类加载器。开发者可以直接使用标准扩展类加载器。

	系统（System）类加载器：开发者可以直接使用系统类加载器。

	线程上下文类加载器

	双亲委派机制：就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

# 23.volatile #

	　　1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。
	
	　　2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。

		3.volatile与synchronized

	    volatile本质是在告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取，synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
	    volatile仅能使用在变量级别，synchronized则可以使用在变量，方法.
	    volatile仅能实现变量的修改可见性，但不具备原子特性，而synchronized则可以保证变量的修改可见性和原子性。
	    volatile不会造成线程的阻塞，而synchronized可能会造成线程的阻塞。
	    volatile标记的变量不会被编译器优化，而synchronized标记的变量可以被编译器优化。

volatile不能保证原子性原因：线程A修改了变量还没结束时，另外的线程B可以看到已修改的值,而且可以修改这个变量，而不用等待A释放锁，因为Volatile 变量没上锁。

# 24.Java垃圾回收 #
	GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法

	什么时候?程序员不能具体控制时间，系统在不可预测的时间调用System.gc()函数的时候；

	对什么东西？超出了作用域或引用计数为空的对象；从gc root开始搜索找不到的对象，而且经过一次标记、清理，仍然没有复活的对象。

	做什么？：删除不使用的对象，回收内存空间；运行默认的finalize,当然程序员想立刻调用就用dipose调用以释放资源如文件句柄，JVM用from survivor、to survivor对它进行标记清理，对象序列化后也可以使它复活。

	使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

# 25.解释Java关键字native, strictfp, transient和volatile #
	(1) native是方法修饰符。native方法是由另外一种语言（如c/c++，FORTRAN，汇编）实现的本地方法。因为在外部实现了方法，所以在java代码中，就不需要声明了，有点类似于接口口方法。native可以和其他一些修饰符连用，但是abstract方法和Interface方法不能用native来修饰。 
	
	(2)strictfp修饰类和方法，意思是FP-strict，精确浮点，符合IEEE-754规范的。当一个class或interface用strictfp声明，内部所有的float和double表达式都会成为strictfp的。Interface method不能被声明为strictfp的，class的可以。 
	
	(3)transient变量修饰符。标记为transient的变量，在对象存储时，这些变量状态不会被持久化。当对象序列化的保存在存储器上时，不希望有些字段数据被保存，为了保证安全性，可以把这些字段声明为transient。 
	
	(4)volatile修饰变量。一个成员变量在每次被线程访问时，都强迫线程从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

# 26.解释Java的反射机制 #
	JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
	Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。

# 27.Servlet的生命周期以及Servlet和CGI的区别 #
	Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。 
	与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。

# 28.final, finally, finalize的区别。 #
	final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
	finally是异常处理语句结构的一部分，表示总是执行。 
	finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。

# 29. #

# 30. #

# 31.forward 和redirect的区别  #
	1. 从地址栏显示来说 
		forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. 
		redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.所以redirect等于客户端向服务器端发出两次request，同时也接受两次response。 
	2.从数据共享来说 
		forward转发页面和转发到的页面可以共享 request里面的数据. 
		redirect不能共享数据. 
		redirect不仅可以重定向到当前应用程序的其他资源,还可以重定向到同一个站点上的其他应用程序中的资源,甚至是使用绝对URL重定向到其他站点的资源. 
		forward方法只能在同一个Web应用程序内的资源之间转发请求. 
		forward是服务器内部的一种操作. 
		redirect是服务器通知客户端,让客户端重新发起请求. 
	3.从运用地方来说 
		forward: 一般用于用户登陆的时候,根据角色转发到相应的模块. 
		redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等. 
	4. 从效率来说 
		forward:高. 
		redirect:低.

# 32.JSP的内置对象及方法。 #
	request 用户端请求，此请求会包含来自GET/POST请求的参数 
	response 网页传回用户端的回应 
	pageContext 网页的属性是在这里管理 
	session 与请求有关的会话期 
	application servlet 正在执行的内容 
	out 用来传送回应的输出 
	config servlet的构架部件 
	page JSP网页本身 
	exception 针对错误网页，未捕捉的例外

# 33.为什么使用Hibernate #
	1，对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 
	2，Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 
	3，hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 
	4，hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 
	5，可扩展，开发者可以根据需求定义查询
# 34.hiberante工作机制 #
	1，读取并解析配置文件 
	2，读取并解析映射信息，创建SessionFactory 
	3，打开Sesssion 
	4，创建事务Transation 
	5，持久化操作 
	6，提交事务 
	7，关闭Session 
	8，关闭SesstionFactory
# 35.为什么用spring #
	AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用 AOP 后，公共服务（比如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。 
	IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词倒置所表明的，IOC就像反过来的JNDI。没有使用一堆抽象工厂、服务定位器、单例（singleton）和直接构造（straight construction），每一个对象都是用其协作对象构造的。因此是由容器管理协作对象（collaborator）。 
	Spring即是一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了 Spring，只要用 JavaBean 属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象。
# 36.spring工作机制  #
	(1) spring mvc请所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责对请求进行真正的处理工作。 
	(2) DispatcherServlet 查询一个或多个HandlerMapping,找到处理请求的Controller. 
	(3) DispatcherServlet将请求提交到目标Controller 
	(4) Controller进行业务逻辑处理后，会返回一个ModelAndView 
	(5) Dispathcher 查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象 
	(6) 视图对象负责渲染返回给客户端

# 37.spring依赖注入的3种实现方式 #
	（1）接口注入（interface injection）
	（2）Set注入（setter injection）
	（3）构造方法注入（constructor injection）


# 38.Statement和PreparedStatement之间的区别 #
	一.PreparedStatement是预编译的,对于批量处理可以大大提高效率，还可以防止sql漏洞注入. 也叫JDBC存储过程
	二.使用Statement 对象。在对数据库只执行一次性存取的时侯，用
	Statement 对象进行处理。PreparedStatement对象的开销比Statement大，对于一次性操作并不会带来额外的好处。
	三.statement每次执行sql语句，相关数据库都要执行sql语句的编译，preparedstatement是预编译得,preparedstatement支持批处理

# 39.json和xml区别 #
	XML:
	(1)应用广泛，可扩展性强，被广泛应用各种场合；
	(2)读取、解析没有JSON快；
	(3)可读性强，可描述复杂结构。
	JSON:
	(1)结构简单，都是键值对；
	(2)读取、解析速度快，很多语言支持；
	(3)传输数据量小，传输速率大大提高；
	(4)描述复杂结构能力较弱。

# 40.线程与进程 #
	1 线程：进程中负责程序执行的执行单元
	线程本身依靠程序进行运行
	线程是程序中的顺序控制流，只能使用分配给程序的资源和环境
	2 进程：执行中的程序
	一个进程至少包含一个线程
	3 单线程：程序中只存在一个线程，实际上主方法就是一个主线程
	4 多线程：在一个程序中运行多个任务
	目的是更好地使用CPU资源
	 5.在Java线程中有两种线程，一种是User Thread（用户线程），另一种是Daemon Thread(守护线程)。
	Daemon的作用是为其他线程的运行提供服务，比如说GC线程。
	 6.一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。

# 41.线程的sleep()方法和yield()方法有什么区别？ #

	① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
	② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
	③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
	④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

# 42.cookie 和session 的区别： #
	
	1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
	
	2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
	   考虑到安全应当使用session。
	
	3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
	   考虑到减轻服务器性能方面，应当使用COOKIE。
	
	4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
	
	5、所以个人建议：
	   将登陆信息等重要信息存放为SESSION
	   其他信息如果需要保留，可以放在COOKIE中

# 43.get与post区别 

	GET在浏览器回退时是无害的，而POST会再次提交请求。

    GET产生的URL地址可以被Bookmark，而POST不可以。

    GET请求会被浏览器主动cache，而POST不会，除非手动设置。

    GET请求只能进行url编码，而POST支持多种编码方式。

    GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

    GET请求在URL中传送的参数是有长度限制的，而POST没有。

    对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

    GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

    GET参数通过URL传递，POST放在Request body中。

	GET产生一个TCP数据包；POST产生两个TCP数据包。

	对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
	
	而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。


# 其他 #

----------

# 1.xml解析方式 #
 - 一.DOM
 - 二.SAX
 - 三.JDOM
 - 四.DOM4J

# 2.j2ee常用的设计模式？说明工厂模式。 #
	Factory（工厂模式），      Builder（建造模式），       Factory Method（工厂方法模式），
	Prototype（原始模型模式），Singleton（单例模式），    Facade（门面模式），
	Adapter（适配器模式），    Bridge（桥梁模式），        Composite（合成模式），
	Decorator（装饰模式），    Flyweight（享元模式），     Proxy（代理模式），
	Command（命令模式），      Interpreter（解释器模式）， Visitor（访问者模式），
	Iterator（迭代子模式），   Mediator（调停者模式），    Memento（备忘录模式），
	Observer（观察者模式），   State（状态模式），         Strategy（策略模式），
	Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）

	单例模式：一个类Class只有一个实例存在

	观察者模式：一个或多个观察者对象监察一个主题对象。这样一个主题对象在状态上的变化能够通知所有的依赖于此对象的那些观察者对象，使这些观察者对象能够自动更新

	适配器模式：使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作

	代理模式：为其他对象提供一种代理以控制对这个对象的访问 

	工厂模式：根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作

# 3.TCP的三次握手和四次挥手 #

	TCP三次握手过程描述如下：
	1.客户端发送SYN标志位为1，Sequence Number为x的连接请求报文段，然后客户端进入SYN_SEND状态，等待服务器的确认响应；
	2.服务器收到客户端的连接请求，对这个SYN报文段进行确认，然后发送Acknowledgment Number为x+1(Sequence Number+1)，SYN标志位和ACK标志位均为1，Sequence Number为y的报文段（即SYN+ACK报文段）给客户端，此时服务器进入SYN_RECV状态；
	3.客户端收到服务器的SYN+ACK报文段，确认ACK后，发送Acknowledgment Number为y+1，SYN标志位为0，ACK标志位为1的报文段，发送完成后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手，客户端和服务器端成功地建立连接，可以开始传输数据了。
	
	当数据传送完成后，为了正确完整的完成数据传输，需要经过四次挥手断开连接。
	
	TCP四次挥手过程描述如下：
	1.客户端发送Sequence Number为x+2，Acknowledgment Number为y+1的FIN报文段，客户端进入FIN_WAIT_1状态，即告诉服务端没有数据需要传输了，请求关闭连接；
	2.服务端收到客户端的FIN报文段后，向客户端应答一个Acknowledgment Number为Sequence Number+1的ACK报文段，即应答客户端你的请求我收到了，但是我还没准备好，请等待我的关闭请求。客户端收到后进入FIN_WAIT_2状态；
	3.服务端完成数据传输后向客户端发送Sequence Number为y+1的FIN报文段，请求关闭连接，服务器进入LAST_ACK状态；
	4.客户端收到服务端的FIN报文段后，向服务端应答一个Acknowledgment Number为Sequence Number+1的ACK报文段，然后客户端进入TIME_WAIT状态；服务端收到客户端的ACK报文段后关闭连接进入CLOSED状态，客户端等待2MSL后依然没有收到回复，则证明服务端已正常关闭，客户端此时关闭连接进入CLOSED状态。

# 4.状态码 #

	100 （继续）说明收到了请求的初始部分，请客户端继续发送
	200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
	400 （错误请求） 服务器不理解请求的语法。 
	404 （未找到） 服务器找不到请求的网页。
	500 （服务器内部错误） 服务器遇到错误，无法完成请求。
	504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 

# 5.ACID #
	事务所具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。
	原子性
    整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
	一致性
    在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
	隔离性
    两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时，中间某一时刻的数据。
	持久性
    在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

# 6.redis五种数据类型 #

	String，Hash，List ，Set，zset

# 7.TCP/IP #


	TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，定义了主机如何连入因特网及数据如何再它们之间传输的标准，
	
	从字面意思来看TCP/IP是TCP和IP协议的合称，但实际上TCP/IP协议是指因特网整个TCP/IP协议族。不同于ISO模型的七个分层，TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中
	
	应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等
	
	传输层：TCP，UDP
	
	网络层：IP，ICMP，OSPF，EIGRP，IGMP
	
	数据链路层：SLIP，CSLIP，PPP，MTU